describe('FX', function() {
  var rect, fx, undefined;

  beforeEach(function() {
    rect = draw.rect(100,100).move(100,100)
    fx = rect.animate(500)

    jasmine.clock().install()
    jasmine.clock().mockDate() // This freeze the Date
  })

  afterEach(function() {
    jasmine.clock().uninstall()

    fx.stop(false, true)
  })


  it('creates an instance of SVG.FX and sets parameter', function() {
    expect(fx instanceof SVG.FX).toBe(true)
    expect(fx._target).toBe(rect)
    expect(fx.absPos).toBe(0)
    expect(fx.pos).toBe(0)
    expect(fx.lastPos).toBe(0)
    expect(fx.paused).toBe(false)
    expect(fx.active).toBe(false)
    expect(fx._speed).toBe(1)
    expect(fx.situations).toEqual([])
    expect(fx.situation.init).toBe(false)
    expect(fx.situation.reversed).toBe(false)
    expect(fx.situation.duration).toBe(500)
    expect(fx.situation.delay).toBe(0)
    expect(fx.situation.loops).toBe(false)
    expect(fx.situation.loop).toBe(0)
    expect(fx.situation.animations).toEqual({})
    expect(fx.situation.attrs).toEqual({})
    expect(fx.situation.styles).toEqual({})
    expect(fx.situation.transforms).toEqual([])
    expect(fx.situation.once).toEqual({})
  })

  describe('animate()', function () {
    it('set duration, ease and delay of the new situation to their default value when they are not passed', function() {
      var defaultDuration = 1000
        , defaultEase = SVG.easing['-']
        , defaultDelay = 0
        , lastSituation = fx.animate().last()

      expect(lastSituation.duration).toBe(defaultDuration)
      expect(lastSituation.ease).toBe(defaultEase)
      expect(lastSituation.delay).toBe(defaultDelay)
    })

    it('use the passed values to set duration, ease and delay of the new situation', function() {
      var duration = 14502
        , ease = '>'
        , delay = 450
        , lastSituation = fx.animate(duration, ease, delay).last()

      expect(lastSituation.duration).toBe(duration)
      expect(lastSituation.ease).toBe(SVG.easing[ease])
      expect(lastSituation.delay).toBe(delay)
    })

    it('allow duration, ease and delay to be passed in an object', function() {
      var o = {
                duration: 7892
              , ease: '<'
              , delay: 1145
              }
        , lastSituation = fx.animate(o).last()

      expect(lastSituation.duration).toBe(o.duration)
      expect(lastSituation.ease).toBe(SVG.easing[o.ease])
      expect(lastSituation.delay).toBe(o.delay)
    })

    it('allow ease to be a custom function', function () {
      var customEase = function() {}
        , lastSituation = fx.animate({ease: customEase}).last()

      expect(lastSituation.ease).toBe(customEase)
    })
  })

  describe('target()', function(){
    it('returns the current fx object with no argument given', function(){
      expect(fx.target()).toBe(rect)
    })

    it('changes the target of the animation when parameter given', function(){
      var c = draw.circle(5)
      expect(fx.target(c).target()).toBe(c)
    })
  })


  describe('timeToAbsPos()', function() {
    it('converts a timestamp to an absolute progress', function() {
      expect(fx.timeToAbsPos( fx.situation.start + fx.situation.duration*0.5 )).toBe(0.5)
    })

    it('should take speed into consideration', function() {
      var spd

      spd = 4
      fx.speed(spd)
      expect(fx.timeToAbsPos( fx.situation.start + (fx.situation.duration/spd)*0.5 )).toBe(0.5)

      spd = 0.5
      fx.speed(spd)
      expect(fx.timeToAbsPos( fx.situation.start + (fx.situation.duration/spd)*0.25 )).toBe(0.25)
    })
  })


  describe('absPosToTime()', function() {
    it('converts an absolute progress to a timestamp', function() {
      expect(fx.absPosToTime(0.5)).toBe( fx.situation.start + fx.situation.duration*0.5 )
    })

    it('should take speed into consideration', function() {
      var spd

      spd = 4
      fx.speed(spd)
      expect(fx.absPosToTime(0.5)).toBe( fx.situation.start + (fx.situation.duration/spd)*0.5 )

      spd = 0.5
      fx.speed(spd)
      expect(fx.absPosToTime(0.25)).toBe( fx.situation.start + (fx.situation.duration/spd)*0.25 )
    })
  })


  describe('atStart()', function () {
    it('sets the animation at the start', function() {
      // When the animation is running forward, the start position is 0
      fx.pos = 0.5
      expect(fx.atStart().pos).toBe(0)

      // When the animation is running backward, the start position is 1
      fx.pos = 0.5
      expect(fx.reverse(true).atStart().pos).toBe(1)
    })

    it('sets the animation at the start, before any loops', function() {
      fx.loop(true)

      // When the animation is running forward, the start position is 0
      fx.at(3.7, true)
      expect(fx.absPos).toBe(3.7)
      expect(fx.pos).toBeCloseTo(0.7)
      expect(fx.situation.loop).toBe(3)

      fx.atStart()
      expect(fx.absPos).toBe(0)
      expect(fx.pos).toBe(0)
      expect(fx.situation.loop).toBe(0)

      // When the animation is running backward, the start position is 1
      fx.reverse(true).at(2.14, true)
      expect(fx.absPos).toBe(2.14)
      expect(fx.pos).toBeCloseTo(1 - 0.14)
      expect(fx.situation.loop).toBe(2)
      expect(fx.situation.reversed).toBe(true)

      fx.atStart()
      expect(fx.absPos).toBe(0)
      expect(fx.pos).toBe(1)
      expect(fx.situation.loop).toBe(0)
      expect(fx.situation.reversed).toBe(true)
    })

    it('sets the animation at the start, before any loops when reversing is true', function() {
      fx.loop(true, true) // Set reversing to true

      // When the animation is running forward, the start position is 0
      fx.at(11.21, true)
      expect(fx.absPos).toBe(11.21)
      expect(fx.pos).toBeCloseTo(1 - 0.21)
      expect(fx.situation.loop).toBe(11)
      expect(fx.situation.reversed).toBe(true)

      fx.atStart()
      expect(fx.absPos).toBe(0)
      expect(fx.pos).toBe(0)
      expect(fx.situation.loop).toBe(0)
      expect(fx.situation.reversed).toBe(false)

      // When the animation is running backward, the start position is 1
      fx.reverse(true).at(14.10, true)
      expect(fx.absPos).toBe(14.10)
      expect(fx.pos).toBeCloseTo(1 - 0.10)
      expect(fx.situation.loop).toBe(14)
      expect(fx.situation.reversed).toBe(true)

      fx.atStart()
      expect(fx.absPos).toBe(0)
      expect(fx.pos).toBe(1)
      expect(fx.situation.loop).toBe(0)
      expect(fx.situation.reversed).toBe(true)
    })
  })


  describe('atEnd()', function () {
    it('sets the animation at the end', function() {
      // When the animation is running forward, the end position is 1
      fx.pos = 0.5
      expect(fx.atEnd().pos).toBe(1)
      expect(fx.situation).toBeNull()

      // Recreate an animation since the other one was ended
      fx.animate()

      // When the animation is running backward, the end position is 0
      fx.pos = 0.5
      expect(fx.reverse(true).atEnd().pos).toBe(0)
      expect(fx.situation).toBeNull()
    })

    it('sets the animation at the end, after all loops', function() {
      var loops

      // When the animation is running forward, the end position is 1
      loops = 12
      fx.loop(loops).start().step()
      expect(fx.absPos).toBe(0)
      expect(fx.pos).toBe(0)
      expect(fx.active).toBe(true)
      expect(fx.situation.loop).toBe(0)
      expect(fx.situation.loops).toBe(loops)

      fx.atEnd()
      expect(fx.absPos).toBe(loops)
      expect(fx.pos).toBe(1)
      expect(fx.active).toBe(false)
      expect(fx.situation).toBeNull()

      // Recreate an animation since the other one was ended
      fx.animate()


      // When the animation is running backward, the end position is 0
      loops = 21
      fx.reverse(true).loop(loops).start().step()
      expect(fx.absPos).toBe(0)
      expect(fx.pos).toBe(1)
      expect(fx.active).toBe(true)
      expect(fx.situation.loop).toBe(0)
      expect(fx.situation.loops).toBe(loops)
      expect(fx.situation.reversed).toBe(true)

      fx.atEnd()
      expect(fx.absPos).toBe(loops)
      expect(fx.pos).toBe(0)
      expect(fx.active).toBe(false)
      expect(fx.situation).toBeNull()
    })

    it('sets the animation at the end, after all loops when reversing is true', function() {
      var loops

      // When reversing is true, the end position is 0 when loops is even and
      // 1 when loops is odd

      // The animation is running forward
      loops = 6
      fx.loop(loops, true).start().step()
      expect(fx.absPos).toBe(0)
      expect(fx.pos).toBe(0)
      expect(fx.active).toBe(true)
      expect(fx.situation.loop).toBe(0)
      expect(fx.situation.loops).toBe(loops)
      expect(fx.situation.reversed).toBe(false)

      fx.atEnd()
      expect(fx.absPos).toBe(loops)
      expect(fx.pos).toBe(0) // End position is 0 because loops is even
      expect(fx.active).toBe(false)
      expect(fx.situation).toBeNull()

      // Recreate an animation since the other one was ended
      fx.animate()

      // When reversing is true and the animation is running backward,
      // the end position is 1 when loops is even and 0 when loops is odd

      // The animation is running backward
      loops = 3
      fx.reverse(true).loop(loops, true).start().step()
      expect(fx.absPos).toBe(0)
      expect(fx.pos).toBe(1)
      expect(fx.active).toBe(true)
      expect(fx.situation.loop).toBe(0)
      expect(fx.situation.loops).toBe(loops)
      expect(fx.situation.reversed).toBe(true)

      fx.atEnd()
      expect(fx.absPos).toBe(loops)
      expect(fx.pos).toBe(0) // End position is 0 because loops is odd
      expect(fx.active).toBe(false)
      expect(fx.situation).toBeNull()
    })

    it('sets the animation at the end of the current iteration when in an infinite loop', function () {
      // When the animation is running forward, the end position is 1
      fx.loop(true).start().step()
      expect(fx.absPos).toBe(0)
      expect(fx.pos).toBe(0)
      expect(fx.active).toBe(true)
      expect(fx.situation.loop).toBe(0)
      expect(fx.situation.loops).toBe(true)

      // Should be halfway through iteration 10
      jasmine.clock().tick(500 * 10 + 250)
      fx.step()
      expect(fx.absPos).toBe(10.5)
      expect(fx.pos).toBe(0.5)
      expect(fx.active).toBe(true)
      expect(fx.situation.loop).toBe(10)
      expect(fx.situation.loops).toBe(true)

      fx.atEnd()
      expect(fx.absPos).toBe(11)
      expect(fx.pos).toBe(1)
      expect(fx.active).toBe(false)
      expect(fx.situation).toBeNull()

      // Recreate an animation since the other one was ended
      fx.animate(500)

      // When the animation is running backward, the end position is 0
      fx.reverse(true).loop(true).start().step()
      expect(fx.absPos).toBe(0)
      expect(fx.pos).toBe(1)
      expect(fx.active).toBe(true)
      expect(fx.situation.loop).toBe(0)
      expect(fx.situation.loops).toBe(true)
      expect(fx.situation.reversed).toBe(true)

      // Should be halfway through iteration 21
      jasmine.clock().tick(500 * 21 + 250)
      fx.step()
      expect(fx.absPos).toBe(21.5)
      expect(fx.pos).toBe(0.5)
      expect(fx.active).toBe(true)
      expect(fx.situation.loop).toBe(21)
      expect(fx.situation.loops).toBe(true)

      fx.atEnd()
      expect(fx.absPos).toBe(22)
      expect(fx.pos).toBe(0)
      expect(fx.active).toBe(false)
      expect(fx.situation).toBeNull()
    })


    it('sets the animation at the end of the current iteration when in an infinite loop and reversing is true', function () {
      // When reversing is true, the end position is 1 when ending on an even
      // iteration and 0 when ending on an odd iteration as illustrated below:

      //   0          Iteration          1
      //   |--------------0------------->|
      //   |<-------------1--------------|
      //   |--------------2------------->|
      //   |<-------------3--------------|
      //                 ...


      // The animation is running forward
      fx.loop(true, true).start().step()
      expect(fx.absPos).toBe(0)
      expect(fx.pos).toBe(0)
      expect(fx.active).toBe(true)
      expect(fx.situation.loop).toBe(0)
      expect(fx.situation.loops).toBe(true)

      // Should be halfway through iteration 11
      jasmine.clock().tick(500 * 11 + 250)
      fx.step()
      expect(fx.absPos).toBe(11.5)
      expect(fx.pos).toBe(0.5)
      expect(fx.active).toBe(true)
      expect(fx.situation.loop).toBe(11)
      expect(fx.situation.loops).toBe(true)

      fx.atEnd()
      expect(fx.absPos).toBe(12)
      expect(fx.pos).toBe(0) // End position is 0 because ended on a odd iteration
      expect(fx.active).toBe(false)
      expect(fx.situation).toBeNull()

      // Recreate an animation since the other one was ended
      fx.animate(500)

      // When reversing is true and the animation is running backward,
      // the end position is 0 when ending on an even iteration and
      // 1 when ending on an odd iteration as illustrated below:

      //   0          Iteration          1
      //   |<-------------0--------------|
      //   |--------------1------------->|
      //   |<-------------2--------------|
      //   |--------------3------------->|
      //                 ...

      // The animation is running backward
      fx.reverse(true).loop(true).start().step()
      expect(fx.absPos).toBe(0)
      expect(fx.pos).toBe(1)
      expect(fx.active).toBe(true)
      expect(fx.situation.loop).toBe(0)
      expect(fx.situation.loops).toBe(true)
      expect(fx.situation.reversed).toBe(true)

      // Should be halfway through iteration 42
      jasmine.clock().tick(500 * 42 + 250)
      fx.step()
      expect(fx.absPos).toBe(42.5)
      expect(fx.pos).toBe(0.5)
      expect(fx.active).toBe(true)
      expect(fx.situation.loop).toBe(42)
      expect(fx.situation.loops).toBe(true)

      fx.atEnd()
      expect(fx.absPos).toBe(43)
      expect(fx.pos).toBe(0) // End position is 0 because ended on an even iteration
      expect(fx.active).toBe(false)
      expect(fx.situation).toBeNull()
    })
  })


  describe('at()', function() {
    it('sets the progress to the specified position', function() {
      var pos

      // Animation running forward
      pos = 0.5
      expect(fx.at(pos).pos).toBe(pos)
      expect(fx.situation.start).toBe(+new Date - fx.situation.duration * pos)

      // Animation running backward
      pos = 0.4
      expect(fx.reverse(true).at(pos).pos).toBe(pos)
      expect(fx.situation.start).toBe(+new Date - fx.situation.duration * (1-pos))
    })

    it('should convert a position to an absolute position', function () {
      var pos, loop, absPos

      fx.loop(true)

      // Animation running forward
      pos = 0.7
      loop = 4
      absPos = pos+loop
      fx.situation.loop = loop
      expect(fx.at(pos).absPos).toBe(absPos)
      expect(fx.situation.start).toBe(+new Date - fx.situation.duration * absPos)

      // Animation running backward
      pos = 0.23
      loop = 9
      absPos = (1-pos)+loop
      fx.situation.loop = loop
      fx.situation.reversed = true
      expect(fx.at(pos).absPos).toBe(absPos)
      expect(fx.situation.start).toBe(+new Date - fx.situation.duration * absPos)

    })

    it('should end the animation when the end position is passed', function() {
      var pos

      fx.start()
      expect(fx.active).toBe(true)
      expect(fx.situation).not.toBeNull()

      // When running forward, the end position is 1
      pos = 1
      expect(fx.at(pos).pos).toBe(pos)
      expect(fx.active).toBe(false)
      expect(fx.situation).toBeNull()

      // Recreate an animation since the other one was ended
      fx.animate().start()
      expect(fx.active).toBe(true)
      expect(fx.situation).not.toBeNull()

      // When running backward, the end position is 0
      pos = 0
      expect(fx.reverse(true).at(pos).pos).toBe(pos)
      expect(fx.active).toBe(false)
      expect(fx.situation).toBeNull()
    })

    it('correct the passed position when it is out of [0,1] and the animation is not looping', function () {
      var pos

      pos = -0.7
      expect(fx.at(pos).pos).toBe(0)

      pos = 1.3
      expect(fx.at(pos).pos).toBe(1)

      // Recreate an animation since the other one was ended
      fx.animate()

      // Should work even when animation is running backward
      pos = 1.3
      expect(fx.reverse(true).at(pos).pos).toBe(1)

      pos = -0.7
      expect(fx.reverse(true).at(pos).pos).toBe(0)
    })

    it('should, when the animation is looping and the passed position is out of [0,1], use the integer part of postion to update the loop counter and set position to its fractional part', function(){
      var loop, pos, posFrac, posInt

      // Without the reverse flag
      fx.loop(10)
      expect(fx.situation.loops).toBe(10)
      expect(fx.situation.loop).toBe(loop = 0)

      pos = 1.3
      posFrac = pos % 1
      posInt = pos - posFrac
      expect(fx.at(pos).pos).toBeCloseTo(posFrac)
      expect(fx.situation.loop).toBe(loop += posInt)

      pos = 7.723
      posFrac = pos % 1
      posInt = pos - posFrac
      expect(fx.at(pos).pos).toBeCloseTo(posFrac)
      expect(fx.situation.loop).toBe(loop += posInt)

      // In this case, pos is above the remaining number of loops, so we expect
      // the position to be set to 1 and the animation to be ended
      pos = 4.3
      posFrac = pos % 1
      posInt = pos - posFrac
      expect(fx.at(pos).pos).toBe(1)
      expect(fx.situation).toBeNull()

      // Recreate an animation since the other one was ended
      fx.animate()

      // With the reverse flag, the position is reversed each time loop is odd
      fx.loop(10, true)
      expect(fx.situation.loops).toBe(10)
      expect(fx.situation.loop).toBe(loop = 0)
      expect(fx.situation.reversed).toBe(false)

      pos = 3.3
      posFrac = pos % 1
      posInt = pos - posFrac
      expect(fx.at(pos).pos).toBeCloseTo(1-posFrac) // Animation is reversed because 0+3 is odd
      expect(fx.situation.loop).toBe(loop += posInt)
      expect(fx.situation.reversed).toBe(true)

      // When the passed position is below 0, the integer part of position is
      // substracted from 1, so, in this case, -0.6 has 1 as is integer part
      // This is necessary so we can add something to the loop counter
      pos = -0.645
      posFrac = (1-pos) % 1
      posInt = (1-pos) - posFrac
      expect(fx.at(pos).pos).toBeCloseTo(posFrac)
      expect(fx.situation.loop).toBe(loop += posInt)
      expect(fx.situation.reversed).toBe(false)

      // In this case, pos is above the remaining number of loop, so we expect
      // the position to be set to 0 (since we end reversed) and the animation to
      // be ended
      pos = 7.2
      posFrac = pos % 1
      posInt = pos - posFrac
      expect(fx.at(pos).pos).toBe(0)
      expect(fx.situation).toBeNull()
    })

    it('should, when the animation is in a infinite loop and the passed position is out of [0,1], use the integer part of postion to update the loop counter and set position to its fractional part', function(){
      var loop, pos, posFrac, posInt

      // Without the reverse flag
      fx.loop(true)
      expect(fx.situation.loops).toBe(true)
      expect(fx.situation.loop).toBe(loop = 0)

      pos = 10.34
      posFrac = pos % 1
      posInt = pos - posFrac
      expect(fx.at(pos).pos).toBeCloseTo(posFrac)
      expect(fx.situation.loop).toBe(loop += posInt)

      // With the reverse flag, the position is reversed each time loop is odd
      fx.loop(true, true)
      expect(fx.situation.loops).toBe(true)
      expect(fx.situation.loop).toBe(loop = 0)
      expect(fx.situation.reversed).toBe(false)

      pos = 3.3
      posFrac = pos % 1
      posInt = pos - posFrac
      expect(fx.at(pos).pos).toBeCloseTo(1-posFrac) // Animation is reversed because 3+0 is odd
      expect(fx.situation.loop).toBe(loop += posInt)
      expect(fx.situation.reversed).toBe(true)

      pos = -8.41
      posFrac = (1-pos) % 1
      posInt = (1-pos) - posFrac
      expect(fx.at(pos).pos).toBeCloseTo(posFrac)
      expect(fx.situation.loop).toBe(loop += posInt)
      expect(fx.situation.reversed).toBe(false)
    })

    it('should take speed into consideration', function() {
      var dur, spd

      dur = fx.situation.duration

      spd = 4
      fx.speed(spd).at(0)
      expect(fx.situation.finish-fx.situation.start).toBe(dur/spd)

      spd = 5
      fx.speed(spd).at(0.15)
      expect(fx.situation.finish-fx.situation.start).toBe(dur/spd)

      spd = 0.25
      fx.speed(spd).at(0.75)
      expect(fx.situation.finish-fx.situation.start).toBe(dur/spd)

      spd = 0.5
      fx.speed(spd).at(0.83)
      expect(fx.situation.finish-fx.situation.start).toBe(dur/spd)
    })

    it('should consider the first parameter as an absolute position when the second parameter is true', function() {
      var absPos

      fx.loop(true)

      absPos = 3.2
      expect(fx.at(absPos, true).absPos).toBe(absPos)

      absPos = -4.27
      expect(fx.at(absPos, true).absPos).toBe(absPos)

      absPos = 0
      expect(fx.at(absPos, true).absPos).toBe(absPos)

      absPos = 1
      expect(fx.at(absPos, true).absPos).toBe(absPos)
    })
  })


  describe('start()', function(){
    it('starts the animation', function() {
      fx.start()
      expect(fx.active).toBe(true)

      jasmine.clock().tick(200)
      fx.step() // Call step to update the animation

      expect(fx.pos).toBeGreaterThan(0)
    })

    it('should take speed into consideration', function() {
      var dur = 500
        , delay = 300
        , spd = 4


      fx.stop().animate(dur, '-', delay).speed(spd).start()
      expect(fx.situation.finish - new Date).toBe(delay/spd + dur/spd)
    })

    it('should do the delay', function() {
      fx.situation.delay = 1000
      expect(fx.start().active).toBe(true)

      jasmine.clock().tick(501)
      fx.step() // Call step to update the animation
      expect(fx.active).toBe(true)

      jasmine.clock().tick(501)
      fx.step() // Call step to update the animation
      expect(fx.active).toBe(true)

      jasmine.clock().tick(501)
      fx.step() // Call step to update the animation
      expect(fx.active).toBe(false)
    })
  })

  describe('delay()', function() {
    it('should push an empty situation with its duration attribute set to the duration of the delay', function() {
      var delay = 8300
      fx.delay(delay)
      expect(fx.situations[0].duration).toBe(delay)
    })
  })


  describe('pause()', function() {
    it('pause the animation', function() {
      expect(fx.pause().paused).toBe(true)
    })
  })

  describe('play()', function() {
    it('returns itself when animation not paused', function() {
      expect(fx.paused).toBe(false)
      expect(fx.play()).toBe(fx)
    })

    it('unpause the animation', function() {
      var start = fx.start().pause().situation.start

      jasmine.clock().tick(200)

      expect(fx.situation.start).toBe(start)
      expect(fx.play().paused).toBe(false)
      expect(fx.situation.start).not.toBe(start)
    })

    it('should not change the position when the animation is unpaused while it is set to run backward', function(){
      var pos = 0.4

      expect(fx.reverse(true).at(pos).pause().play().pos).toBe(pos)
    })

    it('should be able to unpause the delay', function () {
      fx.stop().animate(500, '-', 300).start().step()
      expect(fx.pos).toBe(0)
      expect(fx.absPos).toBeCloseTo(-0.6)

      // At this point, we should have an animation of 500 ms with a delay of
      // 300 ms that should be running.

      jasmine.clock().tick(150)

      // Should be halfway through the delay
      fx.step()
      expect(fx.pos).toBe(0)
      expect(fx.absPos).toBe(-0.3)

      expect(fx.pause().paused).toBe(true) // Pause the delay

      jasmine.clock().tick(150)

      // Unpause, should still be halfway through the delay
      expect(fx.play().paused).toBe(false)
      expect(fx.pos).toBe(0)
      expect(fx.absPos).toBe(-0.3)

      jasmine.clock().tick(150)

      // Delay should be done
      fx.step()
      expect(fx.pos).toBe(0)
      expect(fx.absPos).toBe(0)

      jasmine.clock().tick(500)

      // Animation and delay should be done
      fx.step()
      expect(fx.active).toBe(false)
      expect(fx.pos).toBe(1)
      expect(fx.absPos).toBe(1)
    })
  })


  describe('speed()', function() {
    it('set the speed of the animation', function(){
      var dur, spd

      dur = fx.situation.duration

      spd = 2
      fx.speed(spd)
      expect(fx._speed).toBe(spd)
      expect(fx.situation.finish-fx.situation.start).toBe(dur/spd)

      spd = 0.5
      fx.speed(spd)
      expect(fx._speed).toBe(spd)
      expect(fx.situation.finish-fx.situation.start).toBe(dur/spd)

      spd = 2
      fx.at(0.2).speed(spd)
      expect(fx._speed).toBe(spd)
      expect(fx.situation.finish-fx.situation.start).toBe(dur/spd)

      spd = 1
      fx.speed(spd)
      expect(fx._speed).toBe(spd)
      expect(fx.situation.finish-fx.situation.start).toBe(dur)
    })

    it('should not change the position when the animation is run backward', function(){
      var pos = 0.4

      expect(fx.reverse(true).at(pos).speed(2).pos).toBe(pos)
    })

    it('return the current speed with no argument given', function(){
      var spd

      spd = 2
      fx._speed = spd
      expect(fx.speed()).toBe(spd)

      spd = 0.5
      fx._speed = spd
      expect(fx.speed()).toBe(spd)

      spd = 1
      fx._speed = spd
      expect(fx.speed()).toBe(spd)
    })

    it('pause the animation when a speed of 0 is passed', function(){
      var spd = fx._speed

      expect(fx.speed(0)).toBe(fx)
      expect(fx._speed).toBe(spd)
      expect(fx.paused).toBe(true)
    })

    it('should affect all animations in the queue', function(){
      fx.speed(2).animate(300)
      expect(fx.situations.length).not.toBe(0)
      expect(fx.pos).not.toBe(1)

      // At this point, there should be 2 animations in the queue to be played:
      // the one of 500ms that is added before every test and the one of 300ms
      // we just added. Normally, it would take 800ms before both of these
      // animations are done, but because we set the speed to 2, it should
      // only take 400ms to do both animations.
      fx.start().step()

      jasmine.clock().tick(250)

      // Should be playing the second animation
      fx.step()
      expect(fx.active).toBe(true)
      expect(fx.situations.length).toBe(0)
      expect(fx.pos).not.toBe(1)

      jasmine.clock().tick(150) // 400ms have passed

      // All animations should be done
      fx.step()
      expect(fx.active).toBe(false)
      expect(fx.situations.length).toBe(0)
      expect(fx.pos).toBe(1)
    })

    it('should affect the delay', function() {
      fx.stop().animate(500, '-', 300).start().step()
      expect(fx.pos).toBe(0)
      expect(fx.absPos).toBeCloseTo(-0.6)

      fx.speed(2)
      expect(fx.pos).toBe(0)
      expect(fx.absPos).toBeCloseTo(-0.6)

      // At this point, we should have an animation of 500 ms with a delay of
      // 300 ms that should be running. Normally, it would take 800 ms for the
      // animation and its delay to complete, but because the speed is set to 2
      // , it should only take 400ms

      jasmine.clock().tick(75)

      // Should be halfway through the delay
      fx.step()
      expect(fx.pos).toBe(0)
      expect(fx.absPos).toBe(-0.3)

      jasmine.clock().tick(75)

      // Delay should be done
      fx.step()
      expect(fx.pos).toBe(0)
      expect(fx.absPos).toBe(0)

      jasmine.clock().tick(250)

      // Animation and delay should be done
      fx.step()
      expect(fx.active).toBe(false)
      expect(fx.pos).toBe(1)
      expect(fx.absPos).toBe(1)
    })
  })


  describe('reverse()', function() {
    it('toggles the direction of the animation without a parameter', function() {
      expect(fx.reverse().situation.reversed).toBe(true)
    })
    it('sets the direction to backwards with true given', function() {
      expect(fx.reverse(true).situation.reversed).toBe(true)
    })
    it('sets the direction to forwards with false given', function() {
      expect(fx.reverse(false).situation.reversed).toBe(false)
    })
  })


  describe('queue()', function() {
    it('can add a situation to the queue', function() {
      var situation = new SVG.Situation({duration: 1000, delay: 0, ease: SVG.easing['-']})

      fx.queue(situation)
      expect(fx.situations[0]).toBe(situation)
    })

    it('can add a function to the queue', function() {
      var f = function(){}

      fx.queue(f)
      expect(fx.situations[0]).toBe(f)
    })

    it('should set the situation attribute before pushing something in the situations queue', function(){
      var situation = new SVG.Situation({duration: 1000, delay: 0, ease: SVG.easing['-']})

      // Clear the animation that is created before each test
      fx.stop()

      expect(fx.situation).toBeNull()
      expect(fx.situations.length).toBe(0)
      fx.queue(situation)
      expect(fx.situation).toBe(situation)
      expect(fx.situations.length).toBe(0)
    })
  })


  describe('dequeue()', function() {
    it('should pull the next situtation from the queue', function() {
      var situation = new SVG.Situation({duration: 1000, delay: 0, ease: SVG.easing['-']})

      fx.queue(situation)
      expect(fx.situtation).not.toBe(situation)
      expect(fx.situations[0]).toBe(situation)

      fx.dequeue()
      expect(fx.situation).toBe(situation)
      expect(fx.situations.length).toBe(0)
    })

    it('initialize the animation pulled from the queue to its start position', function() {
      // When the animation is forward, the start position is 0
      fx.animate()
      fx.pos = 0.5
      expect(fx.dequeue().pos).toBe(0)

      // When the animation backward, the start position is 1
      fx.animate().reverse(true)
      fx.pos = 0.5
      expect(fx.dequeue().pos).toBe(1)
    })

    it('when the first element of the queue is a function, it should execute it', function() {
      var called = false

      fx.queue(function(){
        called = true
        expect(this).toBe(fx)
        this.dequeue()
      }).dequeue()

      expect(called).toBe(true)
    })

    it('should stop the currently running animation when there is one', function() {
      fx.start()
      expect(fx.active).toBe(true)
      fx.queue(function() {
        expect(this.active).toBe(false)
        this.dequeue()
      })
      fx.dequeue()
    })
  })


  describe('stop()', function() {
    it('stops the animation immediately without a parameter', function() {
      fx.animate(500).start()
      expect(fx.stop().situation).toBeNull()
      expect(fx.active).toBe(false)
      expect(fx.situations.length).toBe(1)
    })
    it('stops the animation immediately and fullfill it if first parameter true', function() {
      fx.animate(500).start()
      expect(fx.stop(true).situation).toBeNull()
      expect(fx.active).toBe(false)
      expect(fx.pos).toBe(1)
      expect(fx.situations.length).toBe(1)
    })
    it('stops the animation immediately and remove all items from queue when second parameter true', function() {
      fx.animate(500).start()
      expect(fx.stop(false, true).situation).toBeNull()
      expect(fx.active).toBe(false)
      expect(fx.situations.length).toBe(0)
    })
  })


  describe('reset()', function() {
    it('resets the element to the state it was when the current animation was started', function() {
      var loops = 4
        , situation = fx.situation

      // These settings make the animations run backward
      fx.situation.loop = 2
      fx.situation.loops = loops
      fx.situation.reversed = true
      fx.pos = 0.5
      fx.absPos = 2.5

      fx.reset()

      expect(fx.situation).toBe(situation)
      expect(fx.situation.loops).toBe(loops)
      expect(fx.situation.loop).toBe(0)
      expect(fx.situation.reversed).toBe(true) // True because the animation is backward
      expect(fx.pos).toBe(1)
      expect(fx.absPos).toBe(0)
    })
  })


  describe('finish()', function() {
    it('finish the whole animation by fullfilling every single one', function() {
      fx.animate(500)
      expect(fx.finish().pos).toBe(1)
      expect(fx.situations.length).toBe(0)
      expect(fx.situation).toBeNull()
    })
  })


  describe('progress()', function() {
    it('returns the current position', function() {
      expect(fx.progress()).toBe(0)
      expect(fx.progress()).toBe(fx.pos)
    })
    it('returns the current position as eased value if fist argument is true', function() {
      var anim = draw.rect(100,100).animate(500,'>').start()
      expect(anim.progress(true)).toBe(0)

      anim.at(0.25)
      expect(anim.progress(true)).toBeCloseTo(anim.situation.ease(0.25))
    })
  })


  describe('after()', function() {
    it('adds a callback which is called when the current animation is finished', function() {
      var called = false

      fx.start().after(function(situation){
        expect(fx.situation).toBe(situation)
        expect(fx.pos).toBe(1)
        called = true
      })

      jasmine.clock().tick(500)
      fx.step()
      expect(called).toBe(true)
    })
  })


  describe('afterAll()', function() {
    it('adds a callback which is called when all animations are finished', function() {
      var called = false

      fx.animate(150).animate(125).start().afterAll(function(){
        expect(fx.pos).toBe(1)
        expect(fx.situations.length).toBe(0)
        called = true
      })

      expect(fx.situations.length).toBe(2)

      // End of the first animation
      jasmine.clock().tick(500)
      fx.step()
      expect(fx.situations.length).toBe(1)
      expect(called).toBe(false)

      // End of the second animation
      jasmine.clock().tick(150)
      fx.step()
      expect(fx.situations.length).toBe(0)
      expect(called).toBe(false)

      // End of the third and last animation
      jasmine.clock().tick(125)
      fx.step()
      expect(fx.situation).toBeNull()
      expect(called).toBe(true)
    })
  })


  describe('during()', function() {
    it('adds a callback which is called on every animation step', function() {
      var called = 0

      fx.start().during(function(pos, morph, eased, situation){

        expect(fx.situation).toBe(situation)

        switch(++called) {
          case 1:
            expect(pos).toBeCloseTo(0.25)
            break

          case 2:
            expect(pos).toBeCloseTo(0.5)
            break

          case 3:
            expect(pos).toBeCloseTo(0.65)
            break

          case 4:
            expect(pos).toBe(1)
            break
        }

        expect(morph(0, 100)).toBeCloseTo(pos*100)

      })

      jasmine.clock().tick(125)
      fx.step()
      expect(called).toBe(1)

      jasmine.clock().tick(125) // 250 ms have passed
      fx.step()
      expect(called).toBe(2)

      jasmine.clock().tick(75) // 325 ms have passed
      fx.step()
      expect(called).toBe(3)

      jasmine.clock().tick(175) // 500 ms have passed
      fx.step()
      expect(called).toBe(4)
    })
  })


  describe('duringAll()', function() {
    it('adds a callback which is called on every animation step for the whole chain', function() {

      fx.finish()
      rect.off('.fx')

      fx.animate(500).start().animate(500)

      var sit = n