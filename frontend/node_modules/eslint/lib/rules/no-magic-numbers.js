/**
 * @fileoverview Rule to flag statements that use magic numbers (adapted from https://github.com/danielstjules/buddy.js)
 * @author Vincent Lemeunier
 */

"use strict";

const astUtils = require("./utils/ast-utils");

// Maximum array length by the ECMAScript Specification.
const MAX_ARRAY_LENGTH = 2 ** 32 - 1;

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

/**
 * Convert the value to bigint if it's a string. Otherwise return the value as-is.
 * @param {bigint|number|string} x The value to normalize.
 * @returns {bigint|number} The normalized value.
 */
function normalizeIgnoreValue(x) {
    if (typeof x === "string") {
        return BigInt(x.slice(0, -1));
    }
    return x;
}

/** @type {import('../shared/types').Rule} */
module.exports = {
    meta: {
        type: "suggestion",

        docs: {
            description: "Disallow magic numbers",
            recommended: false,
            url: "https://eslint.org/docs/latest/rules/no-magic-numbers"
        },

        schema: [{
            type: "object",
            properties: {
                detectObjects: {
                    type: "boolean",
                    default: false
                },
                enforceConst: {
                    type: "boolean",
                    default: false
                },
                ignore: {
                    type: "array",
                    items: {
                        anyOf: [
                            { type: "number" },
                            { type: "string", pattern: "^[+-]?(?:0|[1-9][0-9]*)n$" }
                        ]
                    },
                    uniqueItems: true
                },
                ignoreArrayIndexes: {
                    type: "boolean",
                    default: false
                },
                ignoreDefaultValues: {
                    type: "boolean",
                    default: false
                },
                ignoreClassFieldInitialValues: {
                    type: "boolean",
                    default: false
                }
            },
            additionalProperties: false
        }],

        messages: {
            useConst: "Number constants declarations must use 'const'.",
            noMagic: "No magic number: {{raw}}."
        }
    },

    create(context) {
        const config = context.options[0] || {},
            detectObjects = !!config.detectObjects,
            enforceConst = !!config.enforceConst,
            ignore = new Set((config.ignore || []).map(normalizeIgnoreValue)),
            ignoreArrayIndexes = !!config.ignoreArrayIndexes,
            ignoreDefaultValues = !!config.ignoreDefaultValues,
            ignoreClassFieldInitialValues = !!config.ignoreClassFieldInitialValues;

        const okTypes = detectObjects ? [] : ["ObjectExpression", "Property", "AssignmentExpression"];

        /**
         * Returns whether the rule is configured to ignore the given value
         * @param {bigint|number} value The value to check
         * @returns {boolean} true if the value is ignored
         */
        function isIgnoredValue(value) {
            return ignore.has(value);
        }

        /**
         * Returns whether the number is a default value assignment.
         * @param {ASTNode} fullNumberNode `Literal` or `UnaryExpression` full number node
         * @returns {boolean} true if the number is a default value
         */
        function isDefaultValue(fullNumberNode) {
            const parent = fullNumberNode.parent;

            return parent.type === "AssignmentPattern" && parent.right === fullNumberNode;
        }

        /**
         * Returns whether the number is the initial value of a class field.
         * @param {ASTNode} fullNumberNode `Literal` or `UnaryExpression` full number node
         * @returns {boolean} true if the number is the initial value of a class field.
         */
        function isClassFieldInitialValue(fullNumberNode) {
            const parent = fullNumberNode.parent;

            return parent.type === "PropertyDefinition" && parent.value === fullNumberNode;
        }

        /**
         * Returns whether the given node is used as a radix within parseInt() or Number.parseInt()
         * @param {ASTNode} fullNumberNode `Literal` or `UnaryExpression` full number node
         * @returns {boolean} true if the node is radix
         */
        function isParseIntRadix(fullNumberNode) {
            const parent = fullNumberNode.parent;

            return parent.type === "CallExpression" && fullNumberNode === parent.arguments[1] &&
                (
                    astUtils.isSpecificId(parent.callee, "parseInt") ||
                    astUtils.isSpecificMemberAccess(parent.callee, "Number", "parseInt")
                );
        }

        /**
         * Returns whether the given node is a direct child of a JSX node.
         * In particular, it aims to detect numbers used as prop values in JSX tags.
         * Example: <input maxLength={10} />
         * @param {ASTNode} fullNumberNode `Literal` or `UnaryExpression` full number node
         * @returns {boolean} true if the node is a JSX number
         */
        function isJSXNumber(fullNumberNode) {
            return fullNumberNode.parent.type.indexOf("JSX") === 0;
        }

        /**
         * Returns whether the given node is used as an array index.
         * Value must coerce to a valid array index name: "0", "1", "2" ... "4294967294".
         *
         * All other values, like "-1", "2.5", or "4294967295", are just "normal" object properties,
         * which can be created and access